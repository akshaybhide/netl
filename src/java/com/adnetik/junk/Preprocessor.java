
package com.adnetik.shared;

import java.util.*;
import java.io.*;

public class Preprocessor
{
	public static final String OPEN_BLOCK = "BEGIN_JCLOSE_PREPROC_BLOCK";
	public static final String CLOSE_BLOCK = "END_JCLOSE_PREPROC_BLOCK";
	
	List<FuncBlock> fcData = Util.vector();
	
	List<String> origLines;
	String targPath;
	
	Integer prevStart;
	Integer prevEnd;
	
	Integer lastCurly;

	public static void main(String[] args)
	{
		String tp = "d:\\userdata\\testcode\\net\\danburfoot\\jclose\\TestPreproc.java";
	
		Preprocessor prep = new Preprocessor(tp);
		prep.go();
	}
	
	public Preprocessor(String tp)
	{
		targPath = tp;
		Util.pf("\nGonna invoke preprocessor on %s", targPath);
		
		
	}
	
	void go()
	{
		try {
			readFileData();	
			
			Util.pf("\nRead %d lines", origLines.size());
			
			//findPrevPrepSection();
			
			findLastCurly();
			
			for(String oneline : origLines)
			{
				if(oneline.indexOf("#DEF") > -1)
				{
					//Util.pf("\nFound funcblock in line %s", oneline);
					FuncBlock fcline = new FuncBlock(oneline);
					
					/*
					Util.pf("\nExpanded form is: ");
					
					for(String expline : fcline.expandedForm())
					{
						Util.pf("\n%s", expline);	
					}
					*/
					
					fcData.add(fcline);
				}
			}
			
			writeNewFile();
			
		} catch (IOException ioex) {
			
			ioex.printStackTrace();
			
		}
	}
	
	// Find the section in the file that was generated by previous
	// invocation of the preprocessor. 
	// If we don't do this we'll get multiple copies.
	/*
	void findPrevPrepSection()
	{
		for(int i = 0; i < origLines.size(); i++)
		{
			if(origLines.get(i).indexOf(OPEN_BLOCK) > -1)
			{
				prevStart = i;	
			}
			
			if(prevStart != null && origLines.get(i).indexOf(CLOSE_BLOCK) > -1)
			{
				prevEnd = i;	
			}
		}
		
		if(prevStart != null)
		{
			Util.pf("\nFound open block tag at %d", prevStart);	
		}
	}
	*/

	
	void findLastCurly()
	{
		for(int i = origLines.size()-1; i >= 0; i--)
		{
			if(origLines.get(i).indexOf("}") > -1)
			{
				lastCurly = i;
				Util.pf("\nLast curly found at line %d", i);
				break;
			}
		}		
	}
	
	void readFileData() throws IOException
	{
		origLines = Util.vector();
		boolean inPrev = false;
		
		for(String line : FileUtils.readFileLinesE(targPath))
		{
			if(line.indexOf(OPEN_BLOCK) > -1)
			{
				inPrev = true;
			}

			if(!inPrev)
				{ origLines.add(line); }
			
			if(line.indexOf(CLOSE_BLOCK) > -1)
			{
				inPrev = false;	
			}
		}
	}
	
	void writeNewFile() throws IOException
	{
		List<String> newfile = Util.vector();
		
		for(int i = 0; i < lastCurly; i++)
		{
			String line = origLines.get(i);
			newfile.add(line);
		}
		
		if(fcData.size() > 0)
		{			
			newfile.add("\t// " + OPEN_BLOCK);
			newfile.add("\t// DO NOT EDIT");
			
			for(FuncBlock fblock : fcData)
			{
				for(String expline : fblock.expandedForm())
					{ newfile.add("\t" + expline);	}
			}
			
			newfile.add("\t// " + CLOSE_BLOCK);
		}
				
		// Shouldn't be too much left over here
		for(int i = lastCurly; i < origLines.size(); i++)
		{
			String line = origLines.get(i);
			newfile.add(line);
		}
				
		FileUtils.writeFileLines(newfile, targPath);
	}
	
	
	class FuncBlock
	{
		String name;
		
		List<String> argNames = Util.vector();
		List<String> argTypes = Util.vector();

		List<String> codelines = Util.vector();
		
		int fCurly; 
		int cCurly;
		int arrowPos;
		
		public FuncBlock(String line)
		{
			Util.massert(line.indexOf("#DEF") > -1, "Could not find code #DEF in line");
			
			int fColon = line.indexOf(":");
			int sColon = line.indexOf(":", fColon+1);
			
			fCurly = line.indexOf("{");
			cCurly = line.indexOf("}"); 
			arrowPos = line.indexOf("=>");
			
			name = line.substring(fColon+1, sColon).trim();
			
			//Util.pf("\nFound func block named %s", name);
			
			popArgMap(line);
			popCodeLines(line);
		}
		
		void popArgMap(String line)
		{
			String argblock = line.substring(fCurly+1, arrowPos);
			Util.pf("\nArg block is %s", argblock);
			
			String[] args = argblock.split(",");
			
			for(String onearg : args)
			{
				//Util.pf("\none arg is %s", onearg);
				String[] type_name = onearg.trim().split(" ");	
				//Util.pf("\n\tArg type is %s, name is %s", type_name[0], type_name[1]);
				
				argNames.add(type_name[1]);
				argTypes.add(type_name[0]);
			}
		}
		
		void popCodeLines(String line)
		{
			String codeblock = line.substring(arrowPos+2, cCurly).trim();
			
			for(String oneline : codeblock.split(";"))
				{ codelines.add(oneline); }
			
			Util.pf("\nRead %d code lines", codelines.size());
		}
		
		List<String> expandedForm()
		{
			List<String> explines = Util.vector();
			
			{
				String typelist = argTypes.toString();
				typelist = typelist.substring(1, typelist.length()-1);
				String impcode = (argTypes.size() == 1 ? "F1" : "F2");
				
				String cdef = Util.sprintf("static class %s implements Jclose.%s<%s>", name, impcode, typelist);
				explines.add(cdef);
			}
			
			explines.add("{");
			
			{
				String fdef = "\tpublic Object f(";
				
				for(int i = 0; i < argNames.size(); i++)
				{
					fdef += argTypes.get(i) + " " + argNames.get(i);
					
					if(i < argNames.size()-1)
						{ fdef += ","; }
				}
				
				fdef += ")";
				explines.add(fdef);
			}
			
			explines.add("\t{");
			
			for(int i = 0; i < codelines.size()-1; i++)
			{
				explines.add("\t\t" + codelines.get(i));
			}
			
			// Last line
			{
				String lastline = codelines.get(codelines.size()-1);
				
				if(lastline.indexOf("return") == -1)
				{
					lastline = "return " + lastline;	
				}
				
				if(lastline.indexOf(";") == -1)
				{
					lastline += ";";	
				}
				
				explines.add("\t\t" + lastline);
			}
			
			explines.add("\t}");
			explines.add("}");
			explines.add("");
			return explines;
		}
				
	}
	
}
